Download Link: https://assignmentchef.com/product/solved-b561-assignment-3-the-postgresql-statements-for-solving-the-problems
<br>
In this assignment, you will be required to use PostgreSQL. Your solutions should include the PostgreSQL statements for solving the problems. Turn in a .sql file with your solutions on IUCanvas as well as a .txt with outputs generated by your solutions. (I.e., use the standard turn-in procedure for assignments.) We furthermore encourage, but not require you to include comments that explain your solutions.

1           Queries with expressions and functions; Boolean queries

For the problems in this section, you can use views (including parameterized views, i.e., user-defined functions) but you can not use aggregate functions nor the GROUP BY and HAVING clauses. You can also not use the INNER JOIN (or other joins) operators.

<ol>

 <li>Let <em>A</em>(<em>x</em>) and <em>B</em>(<em>x</em>) be two unary relation schemas that represent a set <em>A </em>and a set <em>B</em>, respectively. (The domain of <em>x </em>is INTEGER.)

  <ul>

   <li>Write a SQL statement that determines whether it is true or notif <em>A </em>− <em>B </em>is empty, <em>B </em>− <em>A </em>is empty, and <em>A </em>∩ <em>B </em>is empty. Make appropriate use of the SQL operators UNION, INTERSECT and/or EXCEPT in your SQL statement. In this problem, you can not use the set predicates of SQL.</li>

   <li>Repeat problem 1a but this time you can not use UNION, INTERSECT and/or EXCEPT. However, you can use the IN, NOT IN, EXISTS and/or NOT EXISTS.</li>

  </ul></li>

</ol>

For example, if <em>A </em>= {1<em>,</em>2<em>,</em>3} and <em>B </em>= {1<em>,</em>3} then your SQL statements should produce the output:

empty_a_minus_b | empty_b_minus_a | empty_a_intersection_b

—————–+—————–+—————————f              | t            | f

(1 row)

because <em>A </em>− <em>B </em>= {2}, <em>B </em>− <em>A </em>= ∅, and <em>A </em>∩ <em>B </em>= {1}.

Your solution should work for arbitrary <em>A </em>and <em>B</em>.

<ol start="2">

 <li>SQL uses 3-valued logic where it concerns the treatment of NULL (i.e., the value “unknown”). (Read your textbook or search the web for relevant information.) Consider relation schemas p(value), q(value), and r(value) where the type of the attribute value is boolean. In other words, p, q, and r represent propositional (boolean) variables. Populate each of these relations with the possible values true, false, and NULL (i.e., the value unknown).</li>

</ol>

In other words, <em>p</em>, <em>q</em>, and <em>r </em>are as follows:

p                        q                        r

<table width="0">

 <tbody>

  <tr>

   <td width="46">value</td>

   <td rowspan="2" width="32"> </td>

   <td width="46">value</td>

   <td rowspan="2" width="32"> </td>

   <td width="46">value</td>

  </tr>

  <tr>

   <td width="46">t fNULL</td>

   <td width="46">t fNULL</td>

   <td width="46">t fNULL</td>

  </tr>

 </tbody>

</table>

Write a SQL statement that generates the 3-valued truth table for the Propositional Logic formula

(<em>p </em>→ <em>q</em>) → (¬<em>r</em>)

Your statement should return the following answer:

p | q | r | value

—+—+—+——t | t | t | f t | t | f | t t | t | | t | f | t | t t | f | f | t t | f | | t t | | t | t | | f | t t | | |

f | t | t | f f | t | f | t f | t | | f | f | t | f f | f | f | t f | f | | f | | t | f f | | f | t f | | |

| t | t | f

| t | f | t

| t |       |

| f | t |

| f | f | t

| f |       |

|       | t |

|       | f | t

|        | |

(27 rows)

The blank characters in this table represent the NULL (unknown) value.

<ol start="3">

 <li>Consider the relation schema Point(pid<em>,x,y</em>) of a relation of points in the plane. The attribute pid (of type INTEGER) is the identifier of a point, and the attributes <em>x </em>and <em>y</em>, both of type FLOAT, are its <em>x </em>and <em>y </em></li>

</ol>

(a) Write a SQL query that returns the (<em>p</em><sub>1</sub><em>,p</em><sub>2</sub>) pairs of different pids of points that are closest in distance from each other. Recall that if <em>p</em><sub>1 </sub>= (<em>x</em><sub>1</sub><em>,y</em><sub>1</sub>) and <em>p</em><sub>2</sub>(<em>x</em><sub>2</sub><em>,y</em><sub>2</sub>) are two points in the plane, then the distance between them is given by the formula

p(<em>x</em><sub>1</sub>− <em>x</em><sub>2</sub>)2 + (<em>y</em>1− <em>y</em>2)2

For example if you have the following points,

pid | x | y

—-+—+—

<ul>

 <li>| 0 | 0</li>

 <li>| 0 | 1</li>

 <li>| 1 | 0</li>

</ul>

Then your answer should be

p1 | p2

—-+—+—

<ul>

 <li>| 2</li>

 <li>| 1</li>

</ul>

1        | 3

3        | 1

Notice that the pairs (2<em>,</em>3) and (3<em>,</em>2) are not in this answer because the distance between points 2 and 3 is larger than the distance between each pair of points reported in the above answer.

(b) Determine the triples of different points (<em>p</em><sub>1</sub><em>,p</em><sub>2</sub><em>,p</em><sub>3</sub>) that are <em>collinear</em>. Recall that points <em>p</em><sub>1</sub>, <em>p</em><sub>2</sub>, and <em>p</em><sub>3 </sub>are collinear if they lie on the same straight line.

<ol start="4">

 <li>Let <em>R</em>(<em>A,B,C</em>) be a relation schema. The attributes <em>A</em>, <em>B</em>, and <em>C </em>have as their domain INTEGER.

  <ul>

   <li>Write a SQL statement that determines whether or not <em>A </em>is a <em>primary key </em>for the relation <em>R</em>.</li>

   <li>Provide two <em>R </em>instances where one of these instances has <em>A </em>as primary key and the other does not have <em>A </em>has a primary key. Of course, the determination of the primary key property for these instances needs to be verified by using your SQL statement for this problem.</li>

  </ul></li>

</ol>

<h1>2           Queries using aggregate functions</h1>

In the problems in this section, you will practice working with aggregate functions. As explained in the lecture on aggregate functions and partitioning, there are various approaches to accomplish this:

<ul>

 <li>the GROUP BY map COUNT method;</li>

 <li>the user-defined COUNT FUNCTION method; and</li>

 <li>the SELECT COUNT-expression method.</li>

</ul>

To solve the problems in this section, you can freely use any of these methods.

For some of the problems in this section, use the relations student, major, book, and buys that can be found in the data.sql file.

<ol start="5">

 <li>Let <em>M </em>be an <em>n </em>× <em>n </em>matrix of integers (<em>n </em>is a positive integer).</li>

</ol>

For <em>i,j </em>∈ [1<em>,n</em>], we will denote by <em>M</em>[<em>i,j</em>] the element in matrix <em>M </em>at row <em>i </em>and column <em>j</em>.

Given an <em>n</em>×<em>n </em>matrix <em>M</em>, denotes by <em>M</em><sup>2 </sup>the <em>n</em>×<em>n </em>the matrix define such that for <em>i,j </em>∈ [1<em>,n</em>], row <em>i </em>and column <em>j </em>of <em>M</em><sup>2 </sup>is defined by the formula

<em>.</em>

The matrix <em>M </em>can be represented using a ternary relation M with schema (row, colmn, value)<a href="#_ftn1" name="_ftnref1"><sup>[1]</sup></a> as follows: for each pair <em>i,j </em>∈ [1<em>,n</em>], tuple (<em>i,j,v</em>) in M represents that <em>v </em>= <em>M</em>[<em>i,j</em>].

For example if <em>M </em>is the 3 × 3 matrix

1      2        3

<em>M </em>= 1 −3          5

4         0 −2

then M is the following relation of 9 tuples:

M

row colmn value

1           1              1

1           2              2

<ul>

 <li>3 3</li>

 <li>1 1</li>

</ul>

2           2            −3

<ul>

 <li>3 5</li>

 <li>1 4</li>

</ul>

3           2              0

3           3            −2

Let <em>M </em>be an <em>n </em>× <em>n </em>matrix represented by the relation M.

Write a SQL query that computes a relation over schema (row, column, value) that represents the matrix <em>M</em><sup>4</sup>, where <em>M</em><sup>4 </sup>is defined as the matrix (<em>M</em><sup>2</sup>)<sup>2</sup>.

Your solution should work for any <em>n </em>≥ 1.

<ol start="6">

 <li>Let <em>A</em>(<em>x</em>) be a unary relation schema that represent a set <em>A </em>of integers. (So the domain of x in INTEGER.)</li>

</ol>

Define the following equivalence relation on <em>A</em>: for each pair of elements <em>x </em>and <em>y </em>in <em>A</em>, we say that <em>x </em>and <em>y </em>are equivalent if <em>x</em>mod4 = <em>y </em>mod4. (Recall that <em>x</em>mod4 is the remainder of the integer division of <em>x </em>by 4.)

Given a relation <em>A</em>(<em>x</em>) storing a set of integers, determine for each possible remainder value, i.e. 0, 1, 2, or 3, the number of elements in <em>A </em>that are equivalent relative to these values.

<ol start="7">

 <li>Let <em>A</em>(<em>x</em>) be a unary relation schema that represent a <strong>bag </strong><em>A </em>of integers.</li>

</ol>

(So the domain of x in INTEGER.)

For example, we may have the following bag:

<table width="0">

 <tbody>

  <tr>

   <td width="26">A</td>

  </tr>

  <tr>

   <td width="26">x</td>

  </tr>

  <tr>

   <td width="26">5332135</td>

  </tr>

 </tbody>

</table>

Write a SQL query that coerces such a bag into a set which contains the same elements as the bag. (In this problem, you can not use the DISTINCT clause.)

In other words, for the bag above, the query should output the set

<table width="0">

 <tbody>

  <tr>

   <td width="23">x</td>

  </tr>

  <tr>

   <td width="23">1235</td>

  </tr>

 </tbody>

</table>

<ol start="8">

 <li>Formulate the following queries in SQL:

  <ul>

   <li>“Find the bookno’s and titles of books that cost less than $40 andthat where bought by fewer than 3 CS students.”</li>

   <li>“For each student, find the sid and name of that student along withthe number of books bought by that student, provided that the collective cost of these books is less that $200.”</li>

   <li>“Find the sids and names of the students who spent the most on thebooks that they bought.”</li>

   <li>“For each major, specify the combined cost of all the books boughtby students with that major.”</li>

   <li>“Find the pairs of different booknos (<em>b</em><sub>1</sub><em>,b</em><sub>2</sub>) that were bought by the same number of CS students.”</li>

  </ul></li>

</ol>

<h1>3           Queries with quantifiers using Venn diagrams with conditions</h1>

For the following problems, use the relations student, major, book, and buys that can be found in the data.sql file.

Using the method of Venn diagrams with conditions and without using the COUNT function, write SQL queries for the following queries with quantifiers.

In these problems, you must write appropriate views and parameterized views for the sets <em>A </em>and <em>B </em>that occur in the Venn diagram with conditions for these queries. (See the lecture on Queries with Quantifiers.)

<ol start="9">

 <li>Find the sid and name of each student who did not buy all the books thatcost more than $50.</li>

 <li>Find the bookno and title of each book that was not only bought bystudents who major in ‘CS’ or in ’Math’.</li>

 <li>Find the sid and name of each student who bought none of the leastexpensive books.</li>

</ol>

create or replace view leastExpensiveBook as (select b.bookno from book b where b.price = (select min(b1.price) from book b1));

<ol start="12">

 <li>Find the pairs of booknos (<em>b</em><sub>1</sub><em>,b</em><sub>2</sub>) of different books that where bought by the same set of CS students.</li>

</ol>

<h1>4           Queries with quantifiers using Venn diagrams with counting conditions</h1>

Using the method of Venn diagram with counting conditions, write SQL queries for the following queries with quantifiers.

In these problems, you should write appropriate views and parameterized views for the sets <em>A </em>and <em>B </em>that occur in the Venn diagrams for these queries. (See the lecture on Queries with Quantifiers Using the COUNT function.)

<ol start="13">

 <li>Find sid and name of each CS student who bought fewer than 4 booksthat cost less that $50.</li>

 <li>Find the bookno and title of each book that was bought by an odd numberof CS students.</li>

 <li>Find the sid and name of each student who bought all but 3 books.</li>

 <li>Find the pairs of booknos (<em>b</em><sub>1</sub><em>,b</em><sub>2</sub>) of different books such that all the students who bought book <em>b</em><sub>1 </sub>also bought book <em>b</em><sub>2</sub>.</li>

</ol>

<a href="#_ftnref1" name="_ftn1">[1]</a> Notice that we use the attribute name ‘colmn’ since the word ‘column’ is a reserved word in PostgreSQL.